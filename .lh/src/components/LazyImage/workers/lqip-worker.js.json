{
    "sourceFile": "src/components/LazyImage/workers/lqip-worker.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1759221397313,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1759223811127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -145,89 +145,62 @@\n /**\r\n  * 从图片数据生成 LQIP\r\n  */\r\n async function generateLQIPFromImageData(imageData, width, quality, format) {\r\n-  return new Promise((resolve, reject) => {\r\n-    try {\r\n-      // 创建 Blob 和 Object URL\r\n-      const blob = new Blob([imageData.data], { type: \"image/jpeg\" });\r\n-      const imageUrl = URL.createObjectURL(blob);\r\n+  try {\r\n+    // 创建 Blob\r\n+    const blob = new Blob([imageData.data], { type: \"image/jpeg\" });\r\n \r\n-      // 创建图片元素\r\n-      const img = new Image();\r\n+    // 使用 createImageBitmap 替代 Image 构造函数（Web Worker 兼容）\r\n+    const imageBitmap = await createImageBitmap(blob);\r\n \r\n-      img.onload = function () {\r\n-        try {\r\n-          // 创建 Canvas\r\n-          const canvas = new OffscreenCanvas(width, width);\r\n-          const ctx = canvas.getContext(\"2d\");\r\n+    // 创建 Canvas\r\n+    const canvas = new OffscreenCanvas(width, width);\r\n+    const ctx = canvas.getContext(\"2d\");\r\n \r\n-          if (!ctx) {\r\n-            throw new Error(\"无法创建 Canvas 上下文\");\r\n-          }\r\n+    if (!ctx) {\r\n+      throw new Error(\"无法创建 Canvas 上下文\");\r\n+    }\r\n \r\n-          // 计算缩放比例和位置\r\n-          const scale = Math.min(width / img.width, width / img.height);\r\n-          const scaledWidth = img.width * scale;\r\n-          const scaledHeight = img.height * scale;\r\n-          const offsetX = (width - scaledWidth) / 2;\r\n-          const offsetY = (width - scaledHeight) / 2;\r\n+    // 计算缩放比例和位置\r\n+    const scale = Math.min(\r\n+      width / imageBitmap.width,\r\n+      width / imageBitmap.height\r\n+    );\r\n+    const scaledWidth = imageBitmap.width * scale;\r\n+    const scaledHeight = imageBitmap.height * scale;\r\n+    const offsetX = (width - scaledWidth) / 2;\r\n+    const offsetY = (width - scaledHeight) / 2;\r\n \r\n-          // 绘制图片\r\n-          ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);\r\n+    // 绘制图片\r\n+    ctx.drawImage(imageBitmap, offsetX, offsetY, scaledWidth, scaledHeight);\r\n \r\n-          // 转换为 Blob\r\n-          const mimeType = format === \"webp\" ? \"image/webp\" : \"image/jpeg\";\r\n-          canvas\r\n-            .convertToBlob({\r\n-              type: mimeType,\r\n-              quality: quality,\r\n-            })\r\n-            .then((blob) => {\r\n-              // 转换为 Data URL\r\n-              const reader = new FileReader();\r\n-              reader.onload = function () {\r\n-                const dataUrl = reader.result;\r\n-                const compressedSize = dataUrl.length;\r\n+    // 转换为 Blob\r\n+    const mimeType = format === \"webp\" ? \"image/webp\" : \"image/jpeg\";\r\n+    const resultBlob = await canvas.convertToBlob({\r\n+      type: mimeType,\r\n+      quality: quality,\r\n+    });\r\n \r\n-                // 清理资源\r\n-                URL.revokeObjectURL(imageUrl);\r\n+    // 转换为 Data URL\r\n+    const arrayBuffer = await resultBlob.arrayBuffer();\r\n+    const uint8Array = new Uint8Array(arrayBuffer);\r\n+    const base64 = btoa(String.fromCharCode.apply(null, uint8Array));\r\n+    const dataUrl = `data:${mimeType};base64,${base64}`;\r\n+    const compressedSize = dataUrl.length;\r\n \r\n-                resolve({\r\n-                  dataUrl,\r\n-                  originalSize: imageData.size,\r\n-                  compressedSize,\r\n-                  compressionRatio: (compressedSize / imageData.size).toFixed(\r\n-                    2\r\n-                  ),\r\n-                });\r\n-              };\r\n-              reader.onerror = () => {\r\n-                URL.revokeObjectURL(imageUrl);\r\n-                reject(new Error(\"Data URL 转换失败\"));\r\n-              };\r\n-              reader.readAsDataURL(blob);\r\n-            })\r\n-            .catch((error) => {\r\n-              URL.revokeObjectURL(imageUrl);\r\n-              reject(new Error(`Blob 转换失败: ${error.message}`));\r\n-            });\r\n-        } catch (error) {\r\n-          URL.revokeObjectURL(imageUrl);\r\n-          reject(error);\r\n-        }\r\n-      };\r\n+    // 清理资源\r\n+    imageBitmap.close();\r\n \r\n-      img.onerror = function () {\r\n-        URL.revokeObjectURL(imageUrl);\r\n-        reject(new Error(\"图片加载失败\"));\r\n-      };\r\n-\r\n-      img.src = imageUrl;\r\n-    } catch (error) {\r\n-      reject(error);\r\n-    }\r\n-  });\r\n+    return {\r\n+      dataUrl,\r\n+      originalSize: imageData.size,\r\n+      compressedSize,\r\n+      compressionRatio: (compressedSize / imageData.size).toFixed(2),\r\n+    };\r\n+  } catch (error) {\r\n+    throw new Error(`LQIP 生成失败: ${error.message}`);\r\n+  }\r\n }\r\n \r\n /**\r\n  * 错误处理\r\n"
                }
            ],
            "date": 1759221397313,
            "name": "Commit-0",
            "content": "/**\r\n * LQIP Worker - 低质量图像占位符生成器\r\n * 在 Web Worker 中处理图片压缩和 LQIP 生成，避免阻塞主线程\r\n */\r\n\r\n// Worker 状态\r\nlet isReady = false;\r\nlet currentTaskId = null;\r\n\r\n// 发送就绪信号\r\nself.postMessage({ type: \"WORKER_READY\" });\r\nisReady = true;\r\n\r\n/**\r\n * 处理主线程发送的消息\r\n */\r\nself.onmessage = function (event) {\r\n  const { type, taskId, ...data } = event.data;\r\n\r\n  switch (type) {\r\n    case \"GENERATE_LQIP\":\r\n      handleGenerateLQIP(taskId, data);\r\n      break;\r\n\r\n    case \"CANCEL_TASK\":\r\n      handleCancelTask(taskId);\r\n      break;\r\n\r\n    case \"STATUS_REQUEST\":\r\n      handleStatusRequest();\r\n      break;\r\n\r\n    default:\r\n      console.warn(\"LQIP Worker: 未知消息类型\", type);\r\n  }\r\n};\r\n\r\n/**\r\n * 处理 LQIP 生成请求\r\n */\r\nasync function handleGenerateLQIP(\r\n  taskId,\r\n  { imageUrl, width = 24, quality = 0.6, format = \"jpeg\" }\r\n) {\r\n  if (currentTaskId && currentTaskId !== taskId) {\r\n    // 如果有其他任务在进行，取消当前任务\r\n    return;\r\n  }\r\n\r\n  currentTaskId = taskId;\r\n\r\n  try {\r\n    console.log(`LQIP Worker: 开始处理任务 ${taskId}`, {\r\n      imageUrl,\r\n      width,\r\n      quality,\r\n      format,\r\n    });\r\n\r\n    // 获取图片数据\r\n    const imageData = await fetchImageData(imageUrl);\r\n\r\n    // 生成 LQIP\r\n    const result = await generateLQIPFromImageData(\r\n      imageData,\r\n      width,\r\n      quality,\r\n      format\r\n    );\r\n\r\n    // 发送成功结果\r\n    self.postMessage({\r\n      type: \"LQIP_SUCCESS\",\r\n      taskId,\r\n      dataUrl: result.dataUrl,\r\n      originalSize: result.originalSize,\r\n      compressedSize: result.compressedSize,\r\n      compressionRatio: result.compressionRatio,\r\n    });\r\n\r\n    console.log(`LQIP Worker: 任务 ${taskId} 完成`);\r\n  } catch (error) {\r\n    console.error(`LQIP Worker: 任务 ${taskId} 失败`, error);\r\n\r\n    // 发送错误结果\r\n    self.postMessage({\r\n      type: \"LQIP_ERROR\",\r\n      taskId,\r\n      error: error.message || \"未知错误\",\r\n      stack: error.stack,\r\n    });\r\n  } finally {\r\n    currentTaskId = null;\r\n  }\r\n}\r\n\r\n/**\r\n * 处理任务取消请求\r\n */\r\nfunction handleCancelTask(taskId) {\r\n  if (currentTaskId === taskId) {\r\n    console.log(`LQIP Worker: 取消任务 ${taskId}`);\r\n    currentTaskId = null;\r\n\r\n    self.postMessage({\r\n      type: \"TASK_CANCELLED\",\r\n      taskId,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * 处理状态请求\r\n */\r\nfunction handleStatusRequest() {\r\n  self.postMessage({\r\n    type: \"STATUS_RESPONSE\",\r\n    isReady,\r\n    currentTaskId,\r\n    timestamp: Date.now(),\r\n  });\r\n}\r\n\r\n/**\r\n * 获取图片数据\r\n */\r\nasync function fetchImageData(imageUrl) {\r\n  try {\r\n    const response = await fetch(imageUrl);\r\n    if (!response.ok) {\r\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\r\n    }\r\n\r\n    const arrayBuffer = await response.arrayBuffer();\r\n    return {\r\n      data: arrayBuffer,\r\n      size: arrayBuffer.byteLength,\r\n      url: imageUrl,\r\n    };\r\n  } catch (error) {\r\n    throw new Error(`图片获取失败: ${error.message}`);\r\n  }\r\n}\r\n\r\n/**\r\n * 从图片数据生成 LQIP\r\n */\r\nasync function generateLQIPFromImageData(imageData, width, quality, format) {\r\n  return new Promise((resolve, reject) => {\r\n    try {\r\n      // 创建 Blob 和 Object URL\r\n      const blob = new Blob([imageData.data], { type: \"image/jpeg\" });\r\n      const imageUrl = URL.createObjectURL(blob);\r\n\r\n      // 创建图片元素\r\n      const img = new Image();\r\n\r\n      img.onload = function () {\r\n        try {\r\n          // 创建 Canvas\r\n          const canvas = new OffscreenCanvas(width, width);\r\n          const ctx = canvas.getContext(\"2d\");\r\n\r\n          if (!ctx) {\r\n            throw new Error(\"无法创建 Canvas 上下文\");\r\n          }\r\n\r\n          // 计算缩放比例和位置\r\n          const scale = Math.min(width / img.width, width / img.height);\r\n          const scaledWidth = img.width * scale;\r\n          const scaledHeight = img.height * scale;\r\n          const offsetX = (width - scaledWidth) / 2;\r\n          const offsetY = (width - scaledHeight) / 2;\r\n\r\n          // 绘制图片\r\n          ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);\r\n\r\n          // 转换为 Blob\r\n          const mimeType = format === \"webp\" ? \"image/webp\" : \"image/jpeg\";\r\n          canvas\r\n            .convertToBlob({\r\n              type: mimeType,\r\n              quality: quality,\r\n            })\r\n            .then((blob) => {\r\n              // 转换为 Data URL\r\n              const reader = new FileReader();\r\n              reader.onload = function () {\r\n                const dataUrl = reader.result;\r\n                const compressedSize = dataUrl.length;\r\n\r\n                // 清理资源\r\n                URL.revokeObjectURL(imageUrl);\r\n\r\n                resolve({\r\n                  dataUrl,\r\n                  originalSize: imageData.size,\r\n                  compressedSize,\r\n                  compressionRatio: (compressedSize / imageData.size).toFixed(\r\n                    2\r\n                  ),\r\n                });\r\n              };\r\n              reader.onerror = () => {\r\n                URL.revokeObjectURL(imageUrl);\r\n                reject(new Error(\"Data URL 转换失败\"));\r\n              };\r\n              reader.readAsDataURL(blob);\r\n            })\r\n            .catch((error) => {\r\n              URL.revokeObjectURL(imageUrl);\r\n              reject(new Error(`Blob 转换失败: ${error.message}`));\r\n            });\r\n        } catch (error) {\r\n          URL.revokeObjectURL(imageUrl);\r\n          reject(error);\r\n        }\r\n      };\r\n\r\n      img.onerror = function () {\r\n        URL.revokeObjectURL(imageUrl);\r\n        reject(new Error(\"图片加载失败\"));\r\n      };\r\n\r\n      img.src = imageUrl;\r\n    } catch (error) {\r\n      reject(error);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * 错误处理\r\n */\r\nself.onerror = function (error) {\r\n  console.error(\"LQIP Worker 错误:\", error);\r\n\r\n  if (currentTaskId) {\r\n    self.postMessage({\r\n      type: \"LQIP_ERROR\",\r\n      taskId: currentTaskId,\r\n      error: error.message || \"Worker 内部错误\",\r\n      stack: error.stack,\r\n    });\r\n    currentTaskId = null;\r\n  }\r\n};\r\n\r\n/**\r\n * 未捕获的异常处理\r\n */\r\nself.onunhandledrejection = function (event) {\r\n  console.error(\"LQIP Worker 未处理的 Promise 拒绝:\", event.reason);\r\n\r\n  if (currentTaskId) {\r\n    self.postMessage({\r\n      type: \"LQIP_ERROR\",\r\n      taskId: currentTaskId,\r\n      error: event.reason?.message || \"未处理的异常\",\r\n      stack: event.reason?.stack,\r\n    });\r\n    currentTaskId = null;\r\n  }\r\n\r\n  // 阻止默认行为\r\n  event.preventDefault();\r\n};\r\n\r\nconsole.log(\"LQIP Worker 已启动\");\r\n"
        }
    ]
}