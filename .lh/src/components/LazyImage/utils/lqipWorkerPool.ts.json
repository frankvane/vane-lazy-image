{
    "sourceFile": "src/components/LazyImage/utils/lqipWorkerPool.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1759220932897,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1759221100129,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,9 +64,11 @@\n   constructor(options: WorkerPoolOptions = {}) {\n     this.options = {\n       maxWorkers:\n         options.maxWorkers || Math.min(navigator.hardwareConcurrency || 2, 4),\n-      workerScript: options.workerScript || \"/src/workers/lqip-worker.js\",\n+      workerScript:\n+        options.workerScript ||\n+        \"/src/components/LazyImage/workers/lqip-worker.js\",\n       enableFallback: options.enableFallback !== false,\n       taskTimeout: options.taskTimeout || 30000, // 30秒超时\n     };\n   }\n"
                },
                {
                    "date": 1759221336917,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,9 +66,9 @@\n       maxWorkers:\n         options.maxWorkers || Math.min(navigator.hardwareConcurrency || 2, 4),\n       workerScript:\n         options.workerScript ||\n-        \"/src/components/LazyImage/workers/lqip-worker.js\",\n+        new URL(\"../workers/lqip-worker.js\", import.meta.url).href,\n       enableFallback: options.enableFallback !== false,\n       taskTimeout: options.taskTimeout || 30000, // 30秒超时\n     };\n   }\n"
                }
            ],
            "date": 1759220932897,
            "name": "Commit-0",
            "content": "/**\n * LQIP Worker 线程池管理器\n * 管理多个 Worker 实例，提供负载均衡和任务调度\n */\n\nexport interface LQIPTask {\n  taskId: string;\n  imageUrl: string;\n  width?: number;\n  quality?: number;\n  format?: \"jpeg\" | \"webp\";\n  priority?: \"high\" | \"medium\" | \"low\";\n}\n\nexport interface LQIPResult {\n  taskId: string;\n  dataUrl: string;\n  originalSize: number;\n  compressedSize: number;\n  compressionRatio: string;\n}\n\nexport interface LQIPError {\n  taskId: string;\n  error: string;\n  stack?: string;\n}\n\nexport interface WorkerPoolOptions {\n  maxWorkers?: number;\n  workerScript?: string;\n  enableFallback?: boolean;\n  taskTimeout?: number;\n}\n\ninterface WorkerInstance {\n  id: string;\n  worker: Worker;\n  isReady: boolean;\n  isBusy: boolean;\n  currentTaskId: string | null;\n  taskCount: number;\n  lastUsed: number;\n}\n\ninterface PendingTask extends LQIPTask {\n  resolve: (result: LQIPResult) => void;\n  reject: (error: LQIPError) => void;\n  timestamp: number;\n  timeoutId?: ReturnType<typeof setTimeout>;\n}\n\n/**\n * LQIP Worker 线程池\n */\nexport class LQIPWorkerPool {\n  private workers: Map<string, WorkerInstance> = new Map();\n  private pendingTasks: PendingTask[] = [];\n  private options: Required<WorkerPoolOptions>;\n  private isInitialized = false;\n  private initPromise: Promise<void> | null = null;\n  private taskCounter = 0;\n\n  constructor(options: WorkerPoolOptions = {}) {\n    this.options = {\n      maxWorkers:\n        options.maxWorkers || Math.min(navigator.hardwareConcurrency || 2, 4),\n      workerScript: options.workerScript || \"/src/workers/lqip-worker.js\",\n      enableFallback: options.enableFallback !== false,\n      taskTimeout: options.taskTimeout || 30000, // 30秒超时\n    };\n  }\n\n  /**\n   * 初始化 Worker 池\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n    if (this.initPromise) return this.initPromise;\n\n    this.initPromise = this.doInitialize();\n    await this.initPromise;\n  }\n\n  private async doInitialize(): Promise<void> {\n    // 检查 Worker 支持\n    if (typeof Worker === \"undefined\") {\n      if (this.options.enableFallback) {\n        console.warn(\"Web Workers 不支持，将使用主线程降级方案\");\n        this.isInitialized = true;\n        return;\n      } else {\n        throw new Error(\"Web Workers 不支持且未启用降级方案\");\n      }\n    }\n\n    // 检查 OffscreenCanvas 支持\n    if (typeof OffscreenCanvas === \"undefined\") {\n      console.warn(\"OffscreenCanvas 不支持，Worker 性能可能受限\");\n    }\n\n    // 创建 Worker 实例\n    const workerPromises: Promise<void>[] = [];\n\n    for (let i = 0; i < this.options.maxWorkers; i++) {\n      const workerId = `worker-${i}`;\n      workerPromises.push(this.createWorker(workerId));\n    }\n\n    await Promise.all(workerPromises);\n    this.isInitialized = true;\n\n    console.log(\n      `LQIP Worker 池初始化完成，创建了 ${this.workers.size} 个 Worker`\n    );\n  }\n\n  /**\n   * 创建单个 Worker\n   */\n  private async createWorker(workerId: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        const worker = new Worker(this.options.workerScript);\n\n        const workerInstance: WorkerInstance = {\n          id: workerId,\n          worker,\n          isReady: false,\n          isBusy: false,\n          currentTaskId: null,\n          taskCount: 0,\n          lastUsed: Date.now(),\n        };\n\n        // 设置消息处理器\n        worker.onmessage = (event) => {\n          this.handleWorkerMessage(workerId, event.data);\n        };\n\n        // 设置错误处理器\n        worker.onerror = (error) => {\n          console.error(`Worker ${workerId} 错误:`, error);\n          this.handleWorkerError(workerId, error);\n        };\n\n        // 等待 Worker 就绪\n        const readyTimeout = setTimeout(() => {\n          reject(new Error(`Worker ${workerId} 初始化超时`));\n        }, 5000);\n\n        const originalOnMessage = worker.onmessage;\n        worker.onmessage = (event) => {\n          if (event.data.type === \"WORKER_READY\") {\n            clearTimeout(readyTimeout);\n            workerInstance.isReady = true;\n            worker.onmessage = originalOnMessage;\n            resolve();\n          } else {\n            if (originalOnMessage) {\n              originalOnMessage.call(worker, event);\n            }\n          }\n        };\n\n        this.workers.set(workerId, workerInstance);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * 处理 Worker 消息\n   */\n  private handleWorkerMessage(workerId: string, data: any): void {\n    const worker = this.workers.get(workerId);\n    if (!worker) return;\n\n    switch (data.type) {\n      case \"LQIP_SUCCESS\":\n        this.handleTaskSuccess(workerId, data);\n        break;\n\n      case \"LQIP_ERROR\":\n        this.handleTaskError(workerId, data);\n        break;\n\n      case \"TASK_CANCELLED\":\n        this.handleTaskCancelled(workerId, data);\n        break;\n\n      case \"STATUS_RESPONSE\":\n        // 处理状态响应（如果需要）\n        break;\n\n      default:\n        console.warn(`未知的 Worker 消息类型: ${data.type}`);\n    }\n  }\n\n  /**\n   * 处理任务成功\n   */\n  private handleTaskSuccess(workerId: string, data: LQIPResult): void {\n    const worker = this.workers.get(workerId);\n    if (!worker) return;\n\n    // 更新 Worker 状态\n    worker.isBusy = false;\n    worker.currentTaskId = null;\n    worker.taskCount++;\n    worker.lastUsed = Date.now();\n\n    // 查找并完成任务\n    const taskIndex = this.pendingTasks.findIndex(\n      (task) => task.taskId === data.taskId\n    );\n    if (taskIndex !== -1) {\n      const task = this.pendingTasks[taskIndex];\n      this.pendingTasks.splice(taskIndex, 1);\n\n      // 清除超时定时器\n      if (task.timeoutId) {\n        clearTimeout(task.timeoutId);\n      }\n\n      task.resolve(data);\n    }\n\n    // 处理下一个任务\n    this.processNextTask();\n  }\n\n  /**\n   * 处理任务错误\n   */\n  private handleTaskError(workerId: string, data: LQIPError): void {\n    const worker = this.workers.get(workerId);\n    if (!worker) return;\n\n    // 更新 Worker 状态\n    worker.isBusy = false;\n    worker.currentTaskId = null;\n\n    // 查找并拒绝任务\n    const taskIndex = this.pendingTasks.findIndex(\n      (task) => task.taskId === data.taskId\n    );\n    if (taskIndex !== -1) {\n      const task = this.pendingTasks[taskIndex];\n      this.pendingTasks.splice(taskIndex, 1);\n\n      // 清除超时定时器\n      if (task.timeoutId) {\n        clearTimeout(task.timeoutId);\n      }\n\n      task.reject(data);\n    }\n\n    // 处理下一个任务\n    this.processNextTask();\n  }\n\n  /**\n   * 处理任务取消\n   */\n  private handleTaskCancelled(\n    workerId: string,\n    data: { taskId: string }\n  ): void {\n    const worker = this.workers.get(workerId);\n    if (!worker) return;\n\n    // 更新 Worker 状态\n    worker.isBusy = false;\n    worker.currentTaskId = null;\n\n    // 查找并拒绝任务\n    const taskIndex = this.pendingTasks.findIndex(\n      (task) => task.taskId === data.taskId\n    );\n    if (taskIndex !== -1) {\n      const task = this.pendingTasks[taskIndex];\n      this.pendingTasks.splice(taskIndex, 1);\n\n      // 清除超时定时器\n      if (task.timeoutId) {\n        clearTimeout(task.timeoutId);\n      }\n\n      task.reject({\n        taskId: data.taskId,\n        error: \"任务已取消\",\n      });\n    }\n\n    // 处理下一个任务\n    this.processNextTask();\n  }\n\n  /**\n   * 处理 Worker 错误\n   */\n  private handleWorkerError(workerId: string, error: ErrorEvent): void {\n    const worker = this.workers.get(workerId);\n    if (!worker) return;\n\n    console.error(`Worker ${workerId} 发生错误，尝试重启...`);\n\n    // 如果有正在处理的任务，标记为失败\n    if (worker.currentTaskId) {\n      const taskIndex = this.pendingTasks.findIndex(\n        (task) => task.taskId === worker.currentTaskId\n      );\n      if (taskIndex !== -1) {\n        const task = this.pendingTasks[taskIndex];\n        this.pendingTasks.splice(taskIndex, 1);\n\n        if (task.timeoutId) {\n          clearTimeout(task.timeoutId);\n        }\n\n        task.reject({\n          taskId: worker.currentTaskId,\n          error: `Worker 错误: ${error.message}`,\n        });\n      }\n    }\n\n    // 重启 Worker\n    this.restartWorker(workerId);\n  }\n\n  /**\n   * 重启 Worker\n   */\n  private async restartWorker(workerId: string): Promise<void> {\n    const worker = this.workers.get(workerId);\n    if (!worker) return;\n\n    try {\n      // 终止旧 Worker\n      worker.worker.terminate();\n      this.workers.delete(workerId);\n\n      // 创建新 Worker\n      await this.createWorker(workerId);\n      console.log(`Worker ${workerId} 重启成功`);\n    } catch (error) {\n      console.error(`Worker ${workerId} 重启失败:`, error);\n    }\n  }\n\n  /**\n   * 生成 LQIP\n   */\n  async generateLQIP(task: LQIPTask): Promise<LQIPResult> {\n    await this.initialize();\n\n    // 如果没有可用的 Worker，使用降级方案\n    if (this.workers.size === 0) {\n      if (this.options.enableFallback) {\n        return this.generateLQIPFallback(task);\n      } else {\n        throw new Error(\"没有可用的 Worker 且未启用降级方案\");\n      }\n    }\n\n    return new Promise<LQIPResult>((resolve, reject) => {\n      const taskId = task.taskId || this.generateTaskId();\n\n      const pendingTask: PendingTask = {\n        ...task,\n        taskId,\n        resolve,\n        reject,\n        timestamp: Date.now(),\n      };\n\n      // 设置超时\n      pendingTask.timeoutId = setTimeout(() => {\n        const index = this.pendingTasks.findIndex((t) => t.taskId === taskId);\n        if (index !== -1) {\n          this.pendingTasks.splice(index, 1);\n          reject({\n            taskId,\n            error: \"任务超时\",\n          });\n        }\n      }, this.options.taskTimeout);\n\n      this.pendingTasks.push(pendingTask);\n      this.processNextTask();\n    });\n  }\n\n  /**\n   * 处理下一个任务\n   */\n  private processNextTask(): void {\n    if (this.pendingTasks.length === 0) return;\n\n    // 查找空闲的 Worker\n    const availableWorker = this.findAvailableWorker();\n    if (!availableWorker) return;\n\n    // 按优先级排序任务\n    this.pendingTasks.sort((a, b) => {\n      const priorityOrder = { high: 3, medium: 2, low: 1 };\n      const aPriority = priorityOrder[a.priority || \"medium\"];\n      const bPriority = priorityOrder[b.priority || \"medium\"];\n\n      if (aPriority !== bPriority) {\n        return bPriority - aPriority; // 高优先级在前\n      }\n\n      return a.timestamp - b.timestamp; // 相同优先级按时间排序\n    });\n\n    const task = this.pendingTasks[0];\n\n    // 更新 Worker 状态\n    availableWorker.isBusy = true;\n    availableWorker.currentTaskId = task.taskId;\n\n    // 发送任务到 Worker\n    availableWorker.worker.postMessage({\n      type: \"GENERATE_LQIP\",\n      taskId: task.taskId,\n      imageUrl: task.imageUrl,\n      width: task.width || 24,\n      quality: task.quality || 0.6,\n      format: task.format || \"jpeg\",\n    });\n  }\n\n  /**\n   * 查找可用的 Worker\n   */\n  private findAvailableWorker(): WorkerInstance | null {\n    for (const worker of this.workers.values()) {\n      if (worker.isReady && !worker.isBusy) {\n        return worker;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * 生成任务 ID\n   */\n  private generateTaskId(): string {\n    return `lqip-task-${++this.taskCounter}-${Date.now()}`;\n  }\n\n  /**\n   * 降级方案：在主线程生成 LQIP\n   */\n  private async generateLQIPFallback(task: LQIPTask): Promise<LQIPResult> {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      img.crossOrigin = \"anonymous\";\n\n      img.onload = () => {\n        try {\n          const canvas = document.createElement(\"canvas\");\n          const ctx = canvas.getContext(\"2d\");\n\n          if (!ctx) {\n            throw new Error(\"无法创建 Canvas 上下文\");\n          }\n\n          const width = task.width || 24;\n          canvas.width = width;\n          canvas.height = width;\n\n          // 计算缩放比例\n          const scale = Math.min(width / img.width, width / img.height);\n          const scaledWidth = img.width * scale;\n          const scaledHeight = img.height * scale;\n          const offsetX = (width - scaledWidth) / 2;\n          const offsetY = (width - scaledHeight) / 2;\n\n          // 绘制图片\n          ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);\n\n          // 转换为 Data URL\n          const dataUrl = canvas.toDataURL(\n            `image/${task.format || \"jpeg\"}`,\n            task.quality || 0.6\n          );\n\n          resolve({\n            taskId: task.taskId,\n            dataUrl,\n            originalSize: 0, // 降级方案无法获取原始大小\n            compressedSize: dataUrl.length,\n            compressionRatio: \"0.00\",\n          });\n        } catch (error) {\n          reject({\n            taskId: task.taskId,\n            error: error instanceof Error ? error.message : \"降级方案处理失败\",\n          });\n        }\n      };\n\n      img.onerror = () => {\n        reject({\n          taskId: task.taskId,\n          error: \"图片加载失败\",\n        });\n      };\n\n      img.src = task.imageUrl;\n    });\n  }\n\n  /**\n   * 取消任务\n   */\n  cancelTask(taskId: string): void {\n    // 从待处理队列中移除\n    const taskIndex = this.pendingTasks.findIndex(\n      (task) => task.taskId === taskId\n    );\n    if (taskIndex !== -1) {\n      const task = this.pendingTasks[taskIndex];\n      this.pendingTasks.splice(taskIndex, 1);\n\n      if (task.timeoutId) {\n        clearTimeout(task.timeoutId);\n      }\n\n      task.reject({\n        taskId,\n        error: \"任务已取消\",\n      });\n      return;\n    }\n\n    // 取消正在处理的任务\n    for (const worker of this.workers.values()) {\n      if (worker.currentTaskId === taskId) {\n        worker.worker.postMessage({\n          type: \"CANCEL_TASK\",\n          taskId,\n        });\n        break;\n      }\n    }\n  }\n\n  /**\n   * 获取池状态\n   */\n  getStatus() {\n    return {\n      isInitialized: this.isInitialized,\n      workerCount: this.workers.size,\n      busyWorkers: Array.from(this.workers.values()).filter((w) => w.isBusy)\n        .length,\n      pendingTasks: this.pendingTasks.length,\n      workers: Array.from(this.workers.values()).map((w) => ({\n        id: w.id,\n        isReady: w.isReady,\n        isBusy: w.isBusy,\n        taskCount: w.taskCount,\n        currentTaskId: w.currentTaskId,\n      })),\n    };\n  }\n\n  /**\n   * 销毁 Worker 池\n   */\n  destroy(): void {\n    // 取消所有待处理任务\n    for (const task of this.pendingTasks) {\n      if (task.timeoutId) {\n        clearTimeout(task.timeoutId);\n      }\n      task.reject({\n        taskId: task.taskId,\n        error: \"Worker 池已销毁\",\n      });\n    }\n    this.pendingTasks = [];\n\n    // 终止所有 Worker\n    for (const worker of this.workers.values()) {\n      worker.worker.terminate();\n    }\n    this.workers.clear();\n\n    this.isInitialized = false;\n    this.initPromise = null;\n  }\n}\n\n// 全局 Worker 池实例\nlet globalWorkerPool: LQIPWorkerPool | null = null;\n\n/**\n * 获取全局 Worker 池实例\n */\nexport function getLQIPWorkerPool(options?: WorkerPoolOptions): LQIPWorkerPool {\n  if (!globalWorkerPool) {\n    globalWorkerPool = new LQIPWorkerPool(options);\n  }\n  return globalWorkerPool;\n}\n\n/**\n * 重置全局 Worker 池\n */\nexport function resetLQIPWorkerPool(): void {\n  if (globalWorkerPool) {\n    globalWorkerPool.destroy();\n    globalWorkerPool = null;\n  }\n}\n"
        }
    ]
}