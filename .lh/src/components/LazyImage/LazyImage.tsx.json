{
    "sourceFile": "src/components/LazyImage/LazyImage.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1759216729823,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1759220766137,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,315 +1,316 @@\n-/**\r\n- * LazyImage 组件\r\n- * 高性能的 React 图片懒加载组件\r\n- */\r\n-\r\n-import React, { useEffect } from \"react\";\r\n-\r\n-import ImageErrorHandler from \"./components/ImageErrorHandler\";\r\n-import { ImagePreloader } from \"./utils/ImagePreloader\";\r\n-import { LazyImageConfig } from \"./config/LazyImageConfig\";\r\n-import { LazyImageErrorBoundary } from \"./shared/components\";\r\n-import type { LazyImageProps } from \"./types\";\r\n-import LoadingIndicator from \"./components/LoadingIndicator\";\r\n-import Placeholder from \"./components/Placeholder\";\r\n-import styles from \"./style/style.module.css\";\r\n-import { useImageLoader } from \"./hooks/useImageLoader\";\r\n-import { useInView } from \"./hooks/useInView\";\r\n-import { useLQIPGenerator } from \"./hooks/useLQIPGenerator\";\r\n-\r\n-// 扩展 LazyImageProps 以支持 HOC 注入的增强功能\r\n-interface LazyImageInternalProps extends LazyImageProps {\r\n-  // HOC 注入的增强功能 props\r\n-  containerRef?: React.RefObject<HTMLDivElement>;\r\n-  inView?: boolean;\r\n-  shouldLoad?: boolean;\r\n-  imgRef?: React.RefObject<HTMLImageElement>;\r\n-  onImageMount?: (img: HTMLImageElement) => void;\r\n-  onImageUnmount?: () => void;\r\n-  debugInfo?: React.ReactNode;\r\n-\r\n-  // 调试相关（可选）\r\n-  enableDebugInfo?: boolean;\r\n-  distanceFromViewport?: number;\r\n-  loadingPriority?: \"high\" | \"medium\" | \"low\";\r\n-  scrollState?: Record<string, unknown>;\r\n-}\r\n-\r\n-/**\r\n- * LazyImage 组件\r\n- * 支持图片懒加载、LQIP、错误处理等功能\r\n- */\r\n-const LazyImage: React.FC<LazyImageInternalProps> = (props) => {\r\n-  // 从配置系统获取默认值\r\n-  const config = LazyImageConfig.getConfig();\r\n-  \r\n-  // 图片完全准备好的状态（包括解码）\r\n-  const [imageReady, setImageReady] = React.useState(false);\r\n-\r\n-  const {\r\n-    src,\r\n-    alt,\r\n-    style,\r\n-    containerClassName,\r\n-    imgStyle,\r\n-    imgClassName,\r\n-    placeholderStyle,\r\n-    placeholderClassName,\r\n-    placeholder,\r\n-    placeholderSrc,\r\n-    placeholderSvg,\r\n-    root,\r\n-    rootRef,\r\n-    rootMargin = config.rootMargin,\r\n-    threshold = config.threshold,\r\n-    unobserveOnVisible = config.unobserveOnVisible,\r\n-    enablePolyfill = config.enablePolyfill,\r\n-    loading = \"lazy\",\r\n-    decoding = \"async\",\r\n-    fallbackSrc,\r\n-    fallbackSrcs,\r\n-    onLoad,\r\n-    onError,\r\n-    priority = \"medium\",\r\n-    enableCache = true,\r\n-    cacheKey,\r\n-    enableLQIP = false,\r\n-    lqipWidth = config.lqipWidth,\r\n-    lqipQuality = config.lqipQuality,\r\n-    lqipFormat = config.lqipFormat,\r\n-    enableLQIPWorker = true,\r\n-    workerOptions,\r\n-    retryCount = config.retryCount,\r\n-    retryDelayMs = config.retryDelayMs,\r\n-    enableErrorBoundary = true,\r\n-    errorFallback,\r\n-    fetchPriority = \"auto\",\r\n-    preload = false,\r\n-    showLoadingIndicator = false,\r\n-    loadingIndicator,\r\n-    loadingIndicatorStyle,\r\n-    loadingIndicatorClassName,\r\n-\r\n-    // HOC 注入的增强功能 props\r\n-    containerRef: injectedContainerRef,\r\n-    inView: injectedInView,\r\n-    shouldLoad: injectedShouldLoad,\r\n-    imgRef: injectedImgRef,\r\n-    onImageMount,\r\n-    onImageUnmount,\r\n-    debugInfo,\r\n-    enableDebugInfo = false,\r\n-  } = props;\r\n-\r\n-  // 使用 InView hook 检测元素是否在视口内\r\n-  const basicInViewResult = useInView({\r\n-    root,\r\n-    rootRef,\r\n-    rootMargin,\r\n-    threshold,\r\n-    unobserveOnVisible,\r\n-    enablePolyfill,\r\n-  });\r\n-\r\n-  // 优先使用 HOC 注入的 containerRef 和 inView，否则使用基础版本\r\n-  const containerRef = injectedContainerRef || basicInViewResult.containerRef;\r\n-  const inView =\r\n-    injectedInView !== undefined ? injectedInView : basicInViewResult.inView;\r\n-  const shouldLoad =\r\n-    injectedShouldLoad !== undefined ? injectedShouldLoad : inView;\r\n-\r\n-  // 使用 LQIP 生成 hook\r\n-  const { lqipDataUrl } = useLQIPGenerator({\r\n-    src,\r\n-    shouldLoad,\r\n-    enableLQIP,\r\n-    lqipWidth,\r\n-    lqipQuality,\r\n-    lqipFormat,\r\n-    enableLQIPWorker,\r\n-    workerOptions,\r\n-    priority,\r\n-    placeholder,\r\n-    placeholderSrc,\r\n-    placeholderSvg,\r\n-  });\r\n-\r\n-  // 使用图片加载 hook\r\n-  // loaded 状态表示图片已下载但可能还未解码，实际显示使用 imageReady 状态\r\n-  const { displaySrc, loaded, showIndicator } = useImageLoader({\r\n-    src,\r\n-    shouldLoad,\r\n-    priority,\r\n-    enableCache,\r\n-    cacheKey,\r\n-    retryCount,\r\n-    retryDelayMs,\r\n-    fallbackSrc,\r\n-    fallbackSrcs,\r\n-    showLoadingIndicator,\r\n-    // onLoad 回调在 img 元素的 onLoad 中处理，以确保图片完全解码后再调用\r\n-    onLoad: undefined,\r\n-    onError,\r\n-  });\r\n-  \r\n-  // 避免 unused variable 警告\r\n-  void loaded;\r\n-\r\n-  // 图片引用\r\n-  const imgRef = React.useRef<HTMLImageElement | null>(null);\r\n-\r\n-  // 当 src 变化时，重置 imageReady 状态\r\n-  useEffect(() => {\r\n-    setImageReady(false);\r\n-  }, [src]);\r\n-\r\n-  // 处理 preconnect 和 preload\r\n-  useEffect(() => {\r\n-    // 处理 preconnect\r\n-    const cleanupPreconnect = ImagePreloader.preconnect(src, {\r\n-      priority,\r\n-      loading,\r\n-      fetchPriority,\r\n-      preload,\r\n-    });\r\n-\r\n-    // 处理 preload\r\n-    const cleanupPreload = preload ? ImagePreloader.preload(src) : () => {};\r\n-\r\n-    return () => {\r\n-      cleanupPreconnect();\r\n-      cleanupPreload();\r\n-    };\r\n-  }, [src, preload, loading, fetchPriority, priority]);\r\n-\r\n-  // 渲染内容\r\n-  const content = (\r\n-    <div\r\n-      ref={containerRef}\r\n-      className={[styles.container, containerClassName]\r\n-        .filter(Boolean)\r\n-        .join(\" \")}\r\n-      style={{\r\n-        ...style,\r\n-        position: enableDebugInfo ? \"relative\" : style?.position,\r\n-      }}\r\n-      data-inview={inView ? \"true\" : undefined}\r\n-      data-loaded={imageReady ? \"true\" : undefined}\r\n-      data-should-load={shouldLoad ? \"true\" : undefined}\r\n-    >\r\n-      {/* 占位符组件 - 使用 imageReady 而不是 loaded */}\r\n-      <Placeholder\r\n-        loaded={imageReady}\r\n-        placeholder={placeholder}\r\n-        placeholderSvg={placeholderSvg}\r\n-        placeholderSrc={placeholderSrc}\r\n-        lqipDataUrl={lqipDataUrl}\r\n-        placeholderStyle={placeholderStyle}\r\n-        placeholderClassName={placeholderClassName}\r\n-      />\r\n-\r\n-      {/* 加载指示器组件 */}\r\n-      <LoadingIndicator\r\n-        showLoadingIndicator={showLoadingIndicator}\r\n-        showIndicator={showIndicator}\r\n-        loadingIndicator={loadingIndicator}\r\n-        loadingIndicatorStyle={loadingIndicatorStyle}\r\n-        loadingIndicatorClassName={loadingIndicatorClassName}\r\n-      />\r\n-\r\n-      {/* 调试信息 */}\r\n-      {debugInfo}\r\n-\r\n-      {/* 图片和错误处理 */}\r\n-      {displaySrc && (\r\n-        <ImageErrorHandler\r\n-          src={src}\r\n-          fallbackSrc={fallbackSrc}\r\n-          fallbackSrcs={fallbackSrcs}\r\n-          retryCount={retryCount}\r\n-          retryDelayMs={retryDelayMs}\r\n-          onError={onError}\r\n-        >\r\n-          <img\r\n-            src={displaySrc}\r\n-            alt={alt}\r\n-            loading={loading}\r\n-            decoding={decoding}\r\n-            data-loaded={imageReady ? \"true\" : \"false\"}\r\n-            // fetchpriority: 仅部分浏览器支持\r\n-            {...(fetchPriority\r\n-              ? ({ fetchpriority: fetchPriority } as { fetchpriority: string })\r\n-              : {})}\r\n-            onLoad={(e) => {\r\n-              // 图片加载完成后，确保完全解码后再显示\r\n-              const img = e.currentTarget;\r\n-              if (img && 'decode' in img && typeof img.decode === 'function') {\r\n-                img.decode()\r\n-                  .then(() => {\r\n-                    // 图片已完全解码，可以安全显示\r\n-                    setImageReady(true);\r\n-                    onLoad?.();\r\n-                    \r\n-                    // 图片加载完成后调用 onImageMount\r\n-                    if (onImageMount) {\r\n-                      onImageMount(img);\r\n-                    }\r\n-                  })\r\n-                  .catch(() => {\r\n-                    // decode 失败时也允许显示，避免卡住\r\n-                    setImageReady(true);\r\n-                    onLoad?.();\r\n-                    \r\n-                    if (onImageMount) {\r\n-                      onImageMount(img);\r\n-                    }\r\n-                  });\r\n-              } else {\r\n-                // 不支持 decode API 时直接显示\r\n-                setImageReady(true);\r\n-                onLoad?.();\r\n-                \r\n-                if (onImageMount) {\r\n-                  onImageMount(img);\r\n-                }\r\n-              }\r\n-            }}\r\n-            ref={(el) => {\r\n-              // 处理内部 ref\r\n-              imgRef.current = el;\r\n-\r\n-              // 处理注入的 ref（如果存在）\r\n-              if (injectedImgRef && typeof injectedImgRef === \"object\") {\r\n-                (\r\n-                  injectedImgRef as React.MutableRefObject<HTMLImageElement | null>\r\n-                ).current = el;\r\n-              }\r\n-\r\n-              // 处理卸载回调\r\n-              if (!el && onImageUnmount) {\r\n-                onImageUnmount();\r\n-              }\r\n-            }}\r\n-            className={[styles.img, imgClassName].filter(Boolean).join(\" \")}\r\n-            style={imgStyle}\r\n-          />\r\n-        </ImageErrorHandler>\r\n-      )}\r\n-    </div>\r\n-  );\r\n-\r\n-  // 错误边界包装\r\n-  if (enableErrorBoundary) {\r\n-    return (\r\n-      <LazyImageErrorBoundary fallback={errorFallback}>\r\n-        {content}\r\n-      </LazyImageErrorBoundary>\r\n-    );\r\n-  }\r\n-\r\n-  return content;\r\n-};\r\n-\r\n-LazyImage.displayName = \"LazyImage\";\r\n-\r\n-export default LazyImage;\r\n+/**\n+ * LazyImage 组件\n+ * 高性能的 React 图片懒加载组件\n+ */\n+\n+import React, { useEffect } from \"react\";\n+\n+import ImageErrorHandler from \"./components/ImageErrorHandler\";\n+import { ImagePreloader } from \"./utils/ImagePreloader\";\n+import { LazyImageConfig } from \"./config/LazyImageConfig\";\n+import { LazyImageErrorBoundary } from \"./shared/components\";\n+import type { LazyImageProps } from \"./types\";\n+import LoadingIndicator from \"./components/LoadingIndicator\";\n+import Placeholder from \"./components/Placeholder\";\n+import styles from \"./style/style.module.css\";\n+import { useImageLoader } from \"./hooks/useImageLoader\";\n+import { useInView } from \"./hooks/useInView\";\n+import { useLQIPGenerator } from \"./hooks/useLQIPGenerator\";\n+\n+// 扩展 LazyImageProps 以支持 HOC 注入的增强功能\n+interface LazyImageInternalProps extends LazyImageProps {\n+  // HOC 注入的增强功能 props\n+  containerRef?: React.RefObject<HTMLDivElement>;\n+  inView?: boolean;\n+  shouldLoad?: boolean;\n+  imgRef?: React.RefObject<HTMLImageElement>;\n+  onImageMount?: (img: HTMLImageElement) => void;\n+  onImageUnmount?: () => void;\n+  debugInfo?: React.ReactNode;\n+\n+  // 调试相关（可选）\n+  enableDebugInfo?: boolean;\n+  distanceFromViewport?: number;\n+  loadingPriority?: \"high\" | \"medium\" | \"low\";\n+  scrollState?: Record<string, unknown>;\n+}\n+\n+/**\n+ * LazyImage 组件\n+ * 支持图片懒加载、LQIP、错误处理等功能\n+ */\n+const LazyImage: React.FC<LazyImageInternalProps> = (props) => {\n+  // 从配置系统获取默认值\n+  const config = LazyImageConfig.getConfig();\n+\n+  // 图片完全准备好的状态（包括解码）\n+  const [imageReady, setImageReady] = React.useState(false);\n+\n+  const {\n+    src,\n+    alt,\n+    style,\n+    containerClassName,\n+    imgStyle,\n+    imgClassName,\n+    placeholderStyle,\n+    placeholderClassName,\n+    placeholder,\n+    placeholderSrc,\n+    placeholderSvg,\n+    root,\n+    rootRef,\n+    rootMargin = config.rootMargin,\n+    threshold = config.threshold,\n+    unobserveOnVisible = config.unobserveOnVisible,\n+    enablePolyfill = config.enablePolyfill,\n+    loading = \"lazy\",\n+    decoding = \"async\",\n+    fallbackSrc,\n+    fallbackSrcs,\n+    onLoad,\n+    onError,\n+    priority = \"medium\",\n+    enableCache = true,\n+    cacheKey,\n+    enableLQIP = false,\n+    lqipWidth = config.lqipWidth,\n+    lqipQuality = config.lqipQuality,\n+    lqipFormat = config.lqipFormat,\n+    enableLQIPWorker = true,\n+    workerOptions,\n+    retryCount = config.retryCount,\n+    retryDelayMs = config.retryDelayMs,\n+    enableErrorBoundary = true,\n+    errorFallback,\n+    fetchPriority = \"auto\",\n+    preload = false,\n+    showLoadingIndicator = false,\n+    loadingIndicator,\n+    loadingIndicatorStyle,\n+    loadingIndicatorClassName,\n+\n+    // HOC 注入的增强功能 props\n+    containerRef: injectedContainerRef,\n+    inView: injectedInView,\n+    shouldLoad: injectedShouldLoad,\n+    imgRef: injectedImgRef,\n+    onImageMount,\n+    onImageUnmount,\n+    debugInfo,\n+    enableDebugInfo = false,\n+  } = props;\n+\n+  // 使用 InView hook 检测元素是否在视口内\n+  const basicInViewResult = useInView({\n+    root,\n+    rootRef,\n+    rootMargin,\n+    threshold,\n+    unobserveOnVisible,\n+    enablePolyfill,\n+  });\n+\n+  // 优先使用 HOC 注入的 containerRef 和 inView，否则使用基础版本\n+  const containerRef = injectedContainerRef || basicInViewResult.containerRef;\n+  const inView =\n+    injectedInView !== undefined ? injectedInView : basicInViewResult.inView;\n+  const shouldLoad =\n+    injectedShouldLoad !== undefined ? injectedShouldLoad : inView;\n+\n+  // 使用 LQIP 生成 hook\n+  const { lqipDataUrl } = useLQIPGenerator({\n+    src,\n+    shouldLoad,\n+    enableLQIP,\n+    lqipWidth,\n+    lqipQuality,\n+    lqipFormat,\n+    enableLQIPWorker,\n+    workerOptions,\n+    priority,\n+    placeholder,\n+    placeholderSrc,\n+    placeholderSvg,\n+  });\n+\n+  // 使用图片加载 hook\n+  // loaded 状态表示图片已下载但可能还未解码，实际显示使用 imageReady 状态\n+  const { displaySrc, loaded, showIndicator } = useImageLoader({\n+    src,\n+    shouldLoad,\n+    priority,\n+    enableCache,\n+    cacheKey,\n+    retryCount,\n+    retryDelayMs,\n+    fallbackSrc,\n+    fallbackSrcs,\n+    showLoadingIndicator,\n+    // onLoad 回调在 img 元素的 onLoad 中处理，以确保图片完全解码后再调用\n+    onLoad: undefined,\n+    onError,\n+  });\n+\n+  // 避免 unused variable 警告\n+  void loaded;\n+\n+  // 图片引用\n+  const imgRef = React.useRef<HTMLImageElement | null>(null);\n+\n+  // 当 src 变化时，重置 imageReady 状态\n+  useEffect(() => {\n+    setImageReady(false);\n+  }, [src]);\n+\n+  // 处理 preconnect 和 preload\n+  useEffect(() => {\n+    // 处理 preconnect\n+    const cleanupPreconnect = ImagePreloader.preconnect(src, {\n+      priority,\n+      loading,\n+      fetchPriority,\n+      preload,\n+    });\n+\n+    // 处理 preload\n+    const cleanupPreload = preload ? ImagePreloader.preload(src) : () => {};\n+\n+    return () => {\n+      cleanupPreconnect();\n+      cleanupPreload();\n+    };\n+  }, [src, preload, loading, fetchPriority, priority]);\n+\n+  // 渲染内容\n+  const content = (\n+    <div\n+      ref={containerRef}\n+      className={[styles.container, containerClassName]\n+        .filter(Boolean)\n+        .join(\" \")}\n+      style={{\n+        ...style,\n+        position: enableDebugInfo ? \"relative\" : style?.position,\n+      }}\n+      data-inview={inView ? \"true\" : undefined}\n+      data-loaded={imageReady ? \"true\" : undefined}\n+      data-should-load={shouldLoad ? \"true\" : undefined}\n+    >\n+      {/* 占位符组件 - 使用 imageReady 而不是 loaded */}\n+      <Placeholder\n+        loaded={imageReady}\n+        placeholder={placeholder}\n+        placeholderSvg={placeholderSvg}\n+        placeholderSrc={placeholderSrc}\n+        lqipDataUrl={lqipDataUrl}\n+        placeholderStyle={placeholderStyle}\n+        placeholderClassName={placeholderClassName}\n+      />\n+\n+      {/* 加载指示器组件 */}\n+      <LoadingIndicator\n+        showLoadingIndicator={showLoadingIndicator}\n+        showIndicator={showIndicator}\n+        loadingIndicator={loadingIndicator}\n+        loadingIndicatorStyle={loadingIndicatorStyle}\n+        loadingIndicatorClassName={loadingIndicatorClassName}\n+      />\n+\n+      {/* 调试信息 */}\n+      {debugInfo}\n+\n+      {/* 图片和错误处理 */}\n+      {displaySrc && (\n+        <ImageErrorHandler\n+          src={src}\n+          fallbackSrc={fallbackSrc}\n+          fallbackSrcs={fallbackSrcs}\n+          retryCount={retryCount}\n+          retryDelayMs={retryDelayMs}\n+          onError={onError}\n+        >\n+          <img\n+            src={displaySrc}\n+            alt={alt}\n+            loading={loading}\n+            decoding={decoding}\n+            data-loaded={imageReady ? \"true\" : \"false\"}\n+            // fetchpriority: 仅部分浏览器支持\n+            {...(fetchPriority\n+              ? ({ fetchpriority: fetchPriority } as { fetchpriority: string })\n+              : {})}\n+            onLoad={(e) => {\n+              // 图片加载完成后，确保完全解码后再显示\n+              const img = e.currentTarget;\n+              if (img && \"decode\" in img && typeof img.decode === \"function\") {\n+                img\n+                  .decode()\n+                  .then(() => {\n+                    // 图片已完全解码，可以安全显示\n+                    setImageReady(true);\n+                    onLoad?.();\n+\n+                    // 图片加载完成后调用 onImageMount\n+                    if (onImageMount) {\n+                      onImageMount(img);\n+                    }\n+                  })\n+                  .catch(() => {\n+                    // decode 失败时也允许显示，避免卡住\n+                    setImageReady(true);\n+                    onLoad?.();\n+\n+                    if (onImageMount) {\n+                      onImageMount(img);\n+                    }\n+                  });\n+              } else {\n+                // 不支持 decode API 时直接显示\n+                setImageReady(true);\n+                onLoad?.();\n+\n+                if (onImageMount) {\n+                  onImageMount(img);\n+                }\n+              }\n+            }}\n+            ref={(el) => {\n+              // 处理内部 ref\n+              imgRef.current = el;\n+\n+              // 处理注入的 ref（如果存在）\n+              if (injectedImgRef && typeof injectedImgRef === \"object\") {\n+                (\n+                  injectedImgRef as React.MutableRefObject<HTMLImageElement | null>\n+                ).current = el;\n+              }\n+\n+              // 处理卸载回调\n+              if (!el && onImageUnmount) {\n+                onImageUnmount();\n+              }\n+            }}\n+            className={[styles.img, imgClassName].filter(Boolean).join(\" \")}\n+            style={imgStyle}\n+          />\n+        </ImageErrorHandler>\n+      )}\n+    </div>\n+  );\n+\n+  // 错误边界包装\n+  if (enableErrorBoundary) {\n+    return (\n+      <LazyImageErrorBoundary fallback={errorFallback}>\n+        {content}\n+      </LazyImageErrorBoundary>\n+    );\n+  }\n+\n+  return content;\n+};\n+\n+LazyImage.displayName = \"LazyImage\";\n+\n+export default LazyImage;\n"
                },
                {
                    "date": 1759224580701,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -194,8 +194,9 @@\n         position: enableDebugInfo ? \"relative\" : style?.position,\n       }}\n       data-inview={inView ? \"true\" : undefined}\n       data-loaded={imageReady ? \"true\" : undefined}\n+      data-loading={loaded && !imageReady ? \"true\" : undefined}\n       data-should-load={shouldLoad ? \"true\" : undefined}\n     >\n       {/* 占位符组件 - 使用 imageReady 而不是 loaded */}\n       <Placeholder\n"
                },
                {
                    "date": 1759226021447,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -189,8 +189,10 @@\n       className={[styles.container, containerClassName]\n         .filter(Boolean)\n         .join(\" \")}\n       style={{\n+        // 确保背景样式不被覆盖，除非明确指定\n+        background: style?.background || undefined,\n         ...style,\n         position: enableDebugInfo ? \"relative\" : style?.position,\n       }}\n       data-inview={inView ? \"true\" : undefined}\n"
                }
            ],
            "date": 1759216729823,
            "name": "Commit-0",
            "content": "/**\r\n * LazyImage 组件\r\n * 高性能的 React 图片懒加载组件\r\n */\r\n\r\nimport React, { useEffect } from \"react\";\r\n\r\nimport ImageErrorHandler from \"./components/ImageErrorHandler\";\r\nimport { ImagePreloader } from \"./utils/ImagePreloader\";\r\nimport { LazyImageConfig } from \"./config/LazyImageConfig\";\r\nimport { LazyImageErrorBoundary } from \"./shared/components\";\r\nimport type { LazyImageProps } from \"./types\";\r\nimport LoadingIndicator from \"./components/LoadingIndicator\";\r\nimport Placeholder from \"./components/Placeholder\";\r\nimport styles from \"./style/style.module.css\";\r\nimport { useImageLoader } from \"./hooks/useImageLoader\";\r\nimport { useInView } from \"./hooks/useInView\";\r\nimport { useLQIPGenerator } from \"./hooks/useLQIPGenerator\";\r\n\r\n// 扩展 LazyImageProps 以支持 HOC 注入的增强功能\r\ninterface LazyImageInternalProps extends LazyImageProps {\r\n  // HOC 注入的增强功能 props\r\n  containerRef?: React.RefObject<HTMLDivElement>;\r\n  inView?: boolean;\r\n  shouldLoad?: boolean;\r\n  imgRef?: React.RefObject<HTMLImageElement>;\r\n  onImageMount?: (img: HTMLImageElement) => void;\r\n  onImageUnmount?: () => void;\r\n  debugInfo?: React.ReactNode;\r\n\r\n  // 调试相关（可选）\r\n  enableDebugInfo?: boolean;\r\n  distanceFromViewport?: number;\r\n  loadingPriority?: \"high\" | \"medium\" | \"low\";\r\n  scrollState?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * LazyImage 组件\r\n * 支持图片懒加载、LQIP、错误处理等功能\r\n */\r\nconst LazyImage: React.FC<LazyImageInternalProps> = (props) => {\r\n  // 从配置系统获取默认值\r\n  const config = LazyImageConfig.getConfig();\r\n  \r\n  // 图片完全准备好的状态（包括解码）\r\n  const [imageReady, setImageReady] = React.useState(false);\r\n\r\n  const {\r\n    src,\r\n    alt,\r\n    style,\r\n    containerClassName,\r\n    imgStyle,\r\n    imgClassName,\r\n    placeholderStyle,\r\n    placeholderClassName,\r\n    placeholder,\r\n    placeholderSrc,\r\n    placeholderSvg,\r\n    root,\r\n    rootRef,\r\n    rootMargin = config.rootMargin,\r\n    threshold = config.threshold,\r\n    unobserveOnVisible = config.unobserveOnVisible,\r\n    enablePolyfill = config.enablePolyfill,\r\n    loading = \"lazy\",\r\n    decoding = \"async\",\r\n    fallbackSrc,\r\n    fallbackSrcs,\r\n    onLoad,\r\n    onError,\r\n    priority = \"medium\",\r\n    enableCache = true,\r\n    cacheKey,\r\n    enableLQIP = false,\r\n    lqipWidth = config.lqipWidth,\r\n    lqipQuality = config.lqipQuality,\r\n    lqipFormat = config.lqipFormat,\r\n    enableLQIPWorker = true,\r\n    workerOptions,\r\n    retryCount = config.retryCount,\r\n    retryDelayMs = config.retryDelayMs,\r\n    enableErrorBoundary = true,\r\n    errorFallback,\r\n    fetchPriority = \"auto\",\r\n    preload = false,\r\n    showLoadingIndicator = false,\r\n    loadingIndicator,\r\n    loadingIndicatorStyle,\r\n    loadingIndicatorClassName,\r\n\r\n    // HOC 注入的增强功能 props\r\n    containerRef: injectedContainerRef,\r\n    inView: injectedInView,\r\n    shouldLoad: injectedShouldLoad,\r\n    imgRef: injectedImgRef,\r\n    onImageMount,\r\n    onImageUnmount,\r\n    debugInfo,\r\n    enableDebugInfo = false,\r\n  } = props;\r\n\r\n  // 使用 InView hook 检测元素是否在视口内\r\n  const basicInViewResult = useInView({\r\n    root,\r\n    rootRef,\r\n    rootMargin,\r\n    threshold,\r\n    unobserveOnVisible,\r\n    enablePolyfill,\r\n  });\r\n\r\n  // 优先使用 HOC 注入的 containerRef 和 inView，否则使用基础版本\r\n  const containerRef = injectedContainerRef || basicInViewResult.containerRef;\r\n  const inView =\r\n    injectedInView !== undefined ? injectedInView : basicInViewResult.inView;\r\n  const shouldLoad =\r\n    injectedShouldLoad !== undefined ? injectedShouldLoad : inView;\r\n\r\n  // 使用 LQIP 生成 hook\r\n  const { lqipDataUrl } = useLQIPGenerator({\r\n    src,\r\n    shouldLoad,\r\n    enableLQIP,\r\n    lqipWidth,\r\n    lqipQuality,\r\n    lqipFormat,\r\n    enableLQIPWorker,\r\n    workerOptions,\r\n    priority,\r\n    placeholder,\r\n    placeholderSrc,\r\n    placeholderSvg,\r\n  });\r\n\r\n  // 使用图片加载 hook\r\n  // loaded 状态表示图片已下载但可能还未解码，实际显示使用 imageReady 状态\r\n  const { displaySrc, loaded, showIndicator } = useImageLoader({\r\n    src,\r\n    shouldLoad,\r\n    priority,\r\n    enableCache,\r\n    cacheKey,\r\n    retryCount,\r\n    retryDelayMs,\r\n    fallbackSrc,\r\n    fallbackSrcs,\r\n    showLoadingIndicator,\r\n    // onLoad 回调在 img 元素的 onLoad 中处理，以确保图片完全解码后再调用\r\n    onLoad: undefined,\r\n    onError,\r\n  });\r\n  \r\n  // 避免 unused variable 警告\r\n  void loaded;\r\n\r\n  // 图片引用\r\n  const imgRef = React.useRef<HTMLImageElement | null>(null);\r\n\r\n  // 当 src 变化时，重置 imageReady 状态\r\n  useEffect(() => {\r\n    setImageReady(false);\r\n  }, [src]);\r\n\r\n  // 处理 preconnect 和 preload\r\n  useEffect(() => {\r\n    // 处理 preconnect\r\n    const cleanupPreconnect = ImagePreloader.preconnect(src, {\r\n      priority,\r\n      loading,\r\n      fetchPriority,\r\n      preload,\r\n    });\r\n\r\n    // 处理 preload\r\n    const cleanupPreload = preload ? ImagePreloader.preload(src) : () => {};\r\n\r\n    return () => {\r\n      cleanupPreconnect();\r\n      cleanupPreload();\r\n    };\r\n  }, [src, preload, loading, fetchPriority, priority]);\r\n\r\n  // 渲染内容\r\n  const content = (\r\n    <div\r\n      ref={containerRef}\r\n      className={[styles.container, containerClassName]\r\n        .filter(Boolean)\r\n        .join(\" \")}\r\n      style={{\r\n        ...style,\r\n        position: enableDebugInfo ? \"relative\" : style?.position,\r\n      }}\r\n      data-inview={inView ? \"true\" : undefined}\r\n      data-loaded={imageReady ? \"true\" : undefined}\r\n      data-should-load={shouldLoad ? \"true\" : undefined}\r\n    >\r\n      {/* 占位符组件 - 使用 imageReady 而不是 loaded */}\r\n      <Placeholder\r\n        loaded={imageReady}\r\n        placeholder={placeholder}\r\n        placeholderSvg={placeholderSvg}\r\n        placeholderSrc={placeholderSrc}\r\n        lqipDataUrl={lqipDataUrl}\r\n        placeholderStyle={placeholderStyle}\r\n        placeholderClassName={placeholderClassName}\r\n      />\r\n\r\n      {/* 加载指示器组件 */}\r\n      <LoadingIndicator\r\n        showLoadingIndicator={showLoadingIndicator}\r\n        showIndicator={showIndicator}\r\n        loadingIndicator={loadingIndicator}\r\n        loadingIndicatorStyle={loadingIndicatorStyle}\r\n        loadingIndicatorClassName={loadingIndicatorClassName}\r\n      />\r\n\r\n      {/* 调试信息 */}\r\n      {debugInfo}\r\n\r\n      {/* 图片和错误处理 */}\r\n      {displaySrc && (\r\n        <ImageErrorHandler\r\n          src={src}\r\n          fallbackSrc={fallbackSrc}\r\n          fallbackSrcs={fallbackSrcs}\r\n          retryCount={retryCount}\r\n          retryDelayMs={retryDelayMs}\r\n          onError={onError}\r\n        >\r\n          <img\r\n            src={displaySrc}\r\n            alt={alt}\r\n            loading={loading}\r\n            decoding={decoding}\r\n            data-loaded={imageReady ? \"true\" : \"false\"}\r\n            // fetchpriority: 仅部分浏览器支持\r\n            {...(fetchPriority\r\n              ? ({ fetchpriority: fetchPriority } as { fetchpriority: string })\r\n              : {})}\r\n            onLoad={(e) => {\r\n              // 图片加载完成后，确保完全解码后再显示\r\n              const img = e.currentTarget;\r\n              if (img && 'decode' in img && typeof img.decode === 'function') {\r\n                img.decode()\r\n                  .then(() => {\r\n                    // 图片已完全解码，可以安全显示\r\n                    setImageReady(true);\r\n                    onLoad?.();\r\n                    \r\n                    // 图片加载完成后调用 onImageMount\r\n                    if (onImageMount) {\r\n                      onImageMount(img);\r\n                    }\r\n                  })\r\n                  .catch(() => {\r\n                    // decode 失败时也允许显示，避免卡住\r\n                    setImageReady(true);\r\n                    onLoad?.();\r\n                    \r\n                    if (onImageMount) {\r\n                      onImageMount(img);\r\n                    }\r\n                  });\r\n              } else {\r\n                // 不支持 decode API 时直接显示\r\n                setImageReady(true);\r\n                onLoad?.();\r\n                \r\n                if (onImageMount) {\r\n                  onImageMount(img);\r\n                }\r\n              }\r\n            }}\r\n            ref={(el) => {\r\n              // 处理内部 ref\r\n              imgRef.current = el;\r\n\r\n              // 处理注入的 ref（如果存在）\r\n              if (injectedImgRef && typeof injectedImgRef === \"object\") {\r\n                (\r\n                  injectedImgRef as React.MutableRefObject<HTMLImageElement | null>\r\n                ).current = el;\r\n              }\r\n\r\n              // 处理卸载回调\r\n              if (!el && onImageUnmount) {\r\n                onImageUnmount();\r\n              }\r\n            }}\r\n            className={[styles.img, imgClassName].filter(Boolean).join(\" \")}\r\n            style={imgStyle}\r\n          />\r\n        </ImageErrorHandler>\r\n      )}\r\n    </div>\r\n  );\r\n\r\n  // 错误边界包装\r\n  if (enableErrorBoundary) {\r\n    return (\r\n      <LazyImageErrorBoundary fallback={errorFallback}>\r\n        {content}\r\n      </LazyImageErrorBoundary>\r\n    );\r\n  }\r\n\r\n  return content;\r\n};\r\n\r\nLazyImage.displayName = \"LazyImage\";\r\n\r\nexport default LazyImage;\r\n"
        }
    ]
}